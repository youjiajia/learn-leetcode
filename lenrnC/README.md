#c++温习笔记

##基本语法
* C++ 语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了头文件 <iostream>。
* 下一行 using namespace std; 告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。std 是标准库函数使用的命名空间，是 standard（标准）的缩写。
using name space std ，它声明了命名空间 std，后续如果有未指定命名空间的符号，那么默认使用 std，这样就可以使用 cin、cout、vector 等。


##数据类型
* bool
* char
* int
* float
* double
* void
* wchar_t


###类型修饰符
* signed
* unsigned
* short
* long


###类型限定符
* const const 类型的对象在程序执行期间不能被修改改变。
* volatile 告诉编译器，变量的值可能以程序未明确指定的方式被改变。强制程序每次都去内存中取值。多线程中用。
* restrict 由 restrict 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符

###typedef 声明
可以使用 typedef 为一个已有的类型取一个新的名字

###枚举类型
如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓"枚举"是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。

###变量声明
如果你在main中定义了函数a，但是a中main函数下面写的，就需要提前声明函数a
```extern int a, b;```

##定义常量（c++里面一般用const）
* 类型和安全检查不同
宏定义是字符替换，没有数据类型的区别，同时这种替换没有类型安全检查，可能产生边际效应等错误；
const常量是常量的声明，有类型区别，需要在编译阶段进行类型检查
* 编译器处理不同
宏定义是一个"编译时"概念，在预处理阶段展开，不能对宏定义进行调试，生命周期结束与编译时期；
const常量是一个"运行时"概念，在程序运行使用，类似于一个只读行数据
* 存储方式不同
宏定义是直接替换，不会分配内存，存储与程序的代码段中；
const常量需要进行内存分配，存储与程序的数据段中
* 定义域不同
```
	void f1 ()  
	{
	    #define N 12
	    const int n 12;
	}
	void f2 ()
	{
	    cout<<N <<endl; //正确，N已经定义过，不受定义域限制
	    cout<<n <<endl; //错误，n定义域只在f1函数中
	}
```
* 定义后能否取消
宏定义可以通过#undef来使之前的宏定义失效
const常量定义后将在定义域内永久有效
* 是否可以做函数参数
宏定义不能作为参数传递给函数
const常量可以在函数的参数列表中出现

####\#efine宏定义
```#define LENGTH 10  ```

####const
```const int  LENGTH = 10;```
定义成 const 后的常量，程序对其中只能读不能修改

##存储类
* static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此， static 修饰局部变量可以在函数调用之间保持局部变量的值。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。
* extern 存储类 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。
* thread_local 存储类
使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。

##位运算符

|运算符|	描述             |	实例                  |
|-----|:-----------------:|:----------------------:|
|&	|如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。|	(A & B) 将得到 12，即为 0000 1100|
|\|	|如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。|	(A | B) 将得到 61，即为 0011 1101|
|^|	如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。|	(A ^ B) 将得到 49，即为 0011 0001|
|~|	二进制补码运算符是一元运算符，具有"翻转"位效果，即0变成1，1变成0。|	(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。|
|<<	|二进制左移运算符。左操作数的值向左移动右操作数指定的位数。|	A << 2 将得到 240，即为 1111 0000|
|>>	|二进制右移运算符。左操作数的值向右移动右操作数指定的位数。|	A >> 2 将得到 15，即为 0000 1111|

##杂项运算符
|运算符|	描述                               |
|-----|:---------------------------------------:|
|sizeof|	sizeof 运算符返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。|
|Condition ? X : Y|	条件运算符。如果 Condition 为真 ? 则值为 X : 否则值为 Y。|
|,	|逗号运算符会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。|
|.（点 左边必须为实体）和 ->（箭头 左边必须为指针）|	成员运算符用于引用类、结构和共用体的成员。|
|Cast	|强制转换运算符把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。|
|取地址运算符 &	|指针运算符 & 返回变量的地址。例如 &a; 将给出变量的实际内存地址。|
|间接寻址运算符 *	|指针运算符 * 指向一个变量（内存地址）。例如，*var; 将指向变量 var（该内存地址中的值）。|

###goto 语句
goto 语句允许把控制无条件转移到同一函数内的被标记的语句。在任何编程语言中，都不建议使用 goto 语句。goto 语句一个很好的作用是退出深嵌套例程。
```
for(...) {
   for(...) {
      while(...) {
         if(...) goto stop;
         .
         .
         .
      }
   }
}
stop:
cout << "Error in program.\n";
```

##函数

###函数声明
函数声明会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。以下是函数声明：

```int max(int num1, int num2);```

当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。

###函数参数
* 传值调用	该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。(传入变量)
* 指针调用	该方法把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。（传入指针）
* 引用调用	该方法把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。（传入变量）

###Lambda 函数与表达式

